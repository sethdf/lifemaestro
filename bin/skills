#!/usr/bin/env bash
# skills - Manage LifeMaestro skills (local and external) via baton
# Supports installing from GitHub and browsing SkillsMP.com

set -uo pipefail

MAESTRO_ROOT="${MAESTRO_ROOT:-$(cd "$(dirname "$0")/.." && pwd)}"
SKILLS_DIR="$MAESTRO_ROOT/.claude/skills"
EXTERNAL_CACHE="$MAESTRO_ROOT/.cache/external-skills"
BATON_URL="${BATON_URL:-http://localhost:4000}"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
DIM='\033[2m'
BOLD='\033[1m'
NC='\033[0m'

log_info()  { echo -e "${BLUE}ℹ${NC} $*"; }
log_ok()    { echo -e "${GREEN}✓${NC} $*"; }
log_warn()  { echo -e "${YELLOW}!${NC} $*"; }
log_error() { echo -e "${RED}✗${NC} $*" >&2; }

# ============================================
# BATON INTEGRATION
# ============================================

baton_available() {
    curl -s --connect-timeout 1 "$BATON_URL/healthz" &>/dev/null
}

baton_skills_list() {
    curl -s "$BATON_URL/skills" 2>/dev/null
}

baton_skills_search() {
    local query="$1"
    local limit="${2:-20}"
    curl -s "$BATON_URL/skills/search?q=$(echo "$query" | sed 's/ /%20/g')&limit=$limit" 2>/dev/null
}

baton_skills_get() {
    local name="$1"
    curl -s "$BATON_URL/skills/$name" 2>/dev/null
}

baton_skillsmp_search() {
    local query="$1"
    local limit="${2:-20}"
    curl -s "$BATON_URL/skillsmp/search?q=$(echo "$query" | sed 's/ /%20/g')&limit=$limit" 2>/dev/null
}

baton_skillsmp_best() {
    local limit="${1:-20}"
    curl -s "$BATON_URL/skillsmp/best?limit=$limit" 2>/dev/null
}

# ============================================
# LOCAL HELPERS
# ============================================

usage() {
    cat <<EOF
skills - Manage LifeMaestro agent skills via Baton

Usage: skills [command] [args...]

Commands:
    list                    List all installed skills (default)
    search <query>          Search skills (local + SkillsMP)
    install <source>        Install skill from GitHub
    update [name]           Update external skills
    remove <name>           Remove an external skill
    info <name>             Show skill details
    validate [name]         Validate SKILL.md format
    best                    Show top-rated SkillsMP skills

Install Sources:
    GitHub:     skills install owner/repo/path/to/skill
    Anthropic:  skills install anthropic:skill-name

Examples:
    skills list
    skills search "pdf processing"
    skills install anthropics/skills/skills/document-skills
    skills install anthropic:pdf
    skills update
    skills best

Environment:
    BATON_URL       Baton server URL (default: http://localhost:4000)

EOF
}

# Extract description from SKILL.md frontmatter
get_description() {
    local skill_file="$1"
    awk '
        /^description:/ {
            if ($0 ~ /description: [^|]/) {
                sub(/^description: */, "")
                gsub(/"/, "")
                print
                exit
            }
            getline
            while (/^  [^-]/ && !/license:/ && !/allowed/) {
                gsub(/^  /, "")
                print
                exit
            }
        }
    ' "$skill_file"
}

# Print a skill entry
print_skill() {
    local skill_dir="$1"
    local is_external="${2:-false}"
    local name
    name=$(basename "$skill_dir")

    if [[ -f "$skill_dir/SKILL.md" ]]; then
        local desc
        desc=$(get_description "$skill_dir/SKILL.md")
        if [[ "$is_external" == "true" ]]; then
            printf "  %-28s %s ${DIM}[ext]${NC}\n" "$name" "${desc:0:40}"
        else
            printf "  %-28s %s\n" "$name" "${desc:0:45}"
        fi
    else
        printf "  %-28s ${DIM}(no SKILL.md)${NC}\n" "$name"
    fi
}

# Print a group of skills by prefix
print_group() {
    local prefix="$1"
    local label="$2"
    local color="$3"
    local found=0

    for skill_dir in "$SKILLS_DIR"/${prefix}*/; do
        if [[ -d "$skill_dir" ]]; then
            if [[ $found -eq 0 ]]; then
                echo -e "${color}${label}:${NC}"
                found=1
            fi
            local is_ext="false"
            [[ -L "${skill_dir%/}" ]] && is_ext="true"
            print_skill "$skill_dir" "$is_ext"
        fi
    done
    [[ $found -eq 1 ]] && echo ""
}

# ============================================
# COMMANDS
# ============================================

# List all installed skills
cmd_list() {
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${BOLD}              Installed Skills                           ${NC}"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""

    if baton_available; then
        echo -e "${DIM}(via baton @ $BATON_URL)${NC}"
        echo ""
        local result
        result=$(baton_skills_list)
        local total
        total=$(echo "$result" | jq -r '.total // 0')

        if [[ "$total" -gt 0 ]]; then
            echo "$result" | jq -r '.skills[]? | "\(.name)|\(.title // .name)"' | while IFS='|' read -r name title; do
                printf "  ${BOLD}%-25s${NC} %s\n" "$name" "$title"
            done
        else
            echo -e "${DIM}No skills found in cache${NC}"
        fi
        echo ""
        echo -e "${DIM}Total: $total skills${NC}"
    else
        # Fallback to local filesystem scan
        echo -e "${GREEN}Local Skills:${NC}"
        for skill_dir in "$SKILLS_DIR"/*/; do
            [[ -d "$skill_dir" ]] || continue
            name=$(basename "$skill_dir")
            # Skip prefixed and hidden
            [[ "$name" == pai-* || "$name" == anthropic-* || "$name" == .* ]] && continue
            local is_ext="false"
            [[ -L "${skill_dir%/}" ]] && is_ext="true"
            print_skill "$skill_dir" "$is_ext"
        done
        echo ""

        print_group "pai-" "PAI Skills" "$YELLOW"
        print_group "anthropic-" "Anthropic Skills" "$BLUE"
    fi

    echo ""
    echo "Tip: Run 'skills search <query>' to find more skills"
    echo "     Run 'skills best' to see top-rated marketplace skills"
}

# Search skills (local + SkillsMP)
cmd_search() {
    local query="${1:-}"

    if [[ -z "$query" ]]; then
        log_error "Usage: skills search <query>"
        exit 1
    fi

    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${BOLD}              Search Results: $query                      ${NC}"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""

    if baton_available; then
        # Search local skills via baton
        echo -e "${GREEN}Local Skills:${NC}"
        local local_results
        local_results=$(baton_skills_search "$query")
        local local_count
        local_count=$(echo "$local_results" | jq -r '.results | length')

        if [[ "$local_count" -gt 0 ]]; then
            echo "$local_results" | jq -r '.results[]? | "\(.name)|\(.title // .name)"' | while IFS='|' read -r name title; do
                printf "  %-25s %s\n" "$name" "$title"
            done
        else
            echo -e "  ${DIM}No local matches${NC}"
        fi
        echo ""

        # Search SkillsMP via baton
        echo -e "${BLUE}SkillsMP Marketplace:${NC}"
        local mp_results
        mp_results=$(baton_skillsmp_search "$query")

        # Check if SkillsMP is configured
        local error
        error=$(echo "$mp_results" | jq -r '.detail // ""')
        if [[ -n "$error" ]] && [[ "$error" != "null" ]]; then
            echo -e "  ${DIM}SkillsMP not configured${NC}"
        else
            local mp_count
            mp_count=$(echo "$mp_results" | jq -r '.results | length')

            if [[ "$mp_count" -gt 0 ]]; then
                echo "$mp_results" | jq -r '.results[]? | "\(.name)|\(.description // "")|\(.author)|\(.score)"' | head -10 | while IFS='|' read -r name desc author score; do
                    printf "  ${BOLD}%-20s${NC} ${DIM}by %s${NC} (score: %s)\n" "$name" "$author" "$score"
                    [[ -n "$desc" ]] && printf "    ${DIM}%s${NC}\n" "${desc:0:60}"
                done
            else
                echo -e "  ${DIM}No marketplace matches${NC}"
            fi
        fi
    else
        # Fallback: open browser
        log_warn "Baton not available, opening browser..."
        local encoded_query=$(echo "$query" | sed 's/ /+/g')
        local url="https://skillsmp.com/?q=$encoded_query"

        echo "Opening: $url"
        if command -v xdg-open &>/dev/null; then
            xdg-open "$url" 2>/dev/null &
        elif command -v open &>/dev/null; then
            open "$url" 2>/dev/null &
        else
            echo "Visit: $url"
        fi
    fi

    echo ""
    echo "Install with: skills install <github-owner>/<repo>/<path>"
}

# Show best marketplace skills
cmd_best() {
    local limit="${1:-20}"

    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${BOLD}              Top-Rated Skills (SkillsMP)                 ${NC}"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""

    if baton_available; then
        local result
        result=$(baton_skillsmp_best "$limit")

        # Check if SkillsMP is configured
        local error
        error=$(echo "$result" | jq -r '.detail // ""')
        if [[ -n "$error" ]] && [[ "$error" != "null" ]]; then
            log_error "SkillsMP not configured"
            echo ""
            echo "Add SkillsMP API key to Bitwarden as 'SkillsMP API'"
            exit 1
        fi

        local total
        total=$(echo "$result" | jq -r '.total // 0')

        if [[ "$total" -gt 0 ]]; then
            echo "$result" | jq -r '.skills[]? | "\(.name)|\(.description // "")|\(.author)|\(.stars)|\(.score)"' | while IFS='|' read -r name desc author stars score; do
                printf "${BOLD}%-25s${NC} ⭐ %-4s ${DIM}score: %s${NC}\n" "$name" "$stars" "$score"
                printf "  ${DIM}by %s${NC}\n" "$author"
                [[ -n "$desc" ]] && printf "  %s\n" "${desc:0:65}"
                echo ""
            done
        else
            echo -e "${DIM}No skills in cache${NC}"
        fi

        echo -e "${DIM}Showing top $total skills by quality score${NC}"
    else
        log_error "Baton not available"
        echo ""
        echo "Start baton to access SkillsMP cache"
        exit 1
    fi
}

# Install skill from GitHub (local operation)
cmd_install() {
    local source="${1:-}"

    if [[ -z "$source" ]]; then
        log_error "Usage: skills install <source>"
        echo ""
        echo "Sources:"
        echo "  GitHub:    owner/repo/path/to/skill"
        echo "  Anthropic: anthropic:skill-name"
        exit 1
    fi

    # Handle anthropic: shorthand
    if [[ "$source" == anthropic:* ]]; then
        local skill_name="${source#anthropic:}"
        source="anthropics/skills/skills/$skill_name"
    fi

    # Parse GitHub path: owner/repo/path
    local owner repo skill_path skill_name

    # Split by /
    IFS='/' read -r owner repo rest <<< "$source"

    if [[ -z "$owner" ]] || [[ -z "$repo" ]]; then
        log_error "Invalid source format. Use: owner/repo/path/to/skill"
        exit 1
    fi

    # Reconstruct skill path (everything after owner/repo)
    skill_path="${source#$owner/$repo/}"
    skill_name=$(basename "$skill_path")

    log_info "Installing skill: $skill_name"
    log_info "  From: github.com/$owner/$repo"
    log_info "  Path: $skill_path"

    # Create cache directory
    mkdir -p "$EXTERNAL_CACHE"

    # Clone or update the repo
    local repo_dir="$EXTERNAL_CACHE/$owner-$repo"

    if [[ -d "$repo_dir/.git" ]]; then
        log_info "Updating repository..."
        git -C "$repo_dir" pull --quiet 2>/dev/null || log_warn "Could not update repo"
    else
        log_info "Cloning repository..."
        if ! git clone --depth 1 --quiet "https://github.com/$owner/$repo.git" "$repo_dir" 2>/dev/null; then
            log_error "Failed to clone repository"
            exit 1
        fi
    fi

    # Verify skill exists
    local source_skill_dir="$repo_dir/$skill_path"

    if [[ ! -f "$source_skill_dir/SKILL.md" ]]; then
        log_error "No SKILL.md found at: $skill_path"
        log_error "Available paths:"
        find "$repo_dir" -name "SKILL.md" -type f 2>/dev/null | head -5 | sed "s|$repo_dir/||" | sed 's|/SKILL.md||' | sed 's/^/  /'
        exit 1
    fi

    # Create symlink
    local link_name="$SKILLS_DIR/$skill_name"

    if [[ -e "$link_name" ]]; then
        if [[ -L "$link_name" ]]; then
            log_warn "Skill already installed, updating link..."
            rm "$link_name"
        else
            log_error "Local skill with same name exists: $skill_name"
            exit 1
        fi
    fi

    ln -s "$source_skill_dir" "$link_name"

    log_ok "Installed: $skill_name"
    echo ""

    # Refresh baton cache if available
    if baton_available; then
        curl -s -X POST "$BATON_URL/skills/refresh" &>/dev/null
        log_info "Baton skills cache refreshed"
    fi

    # Show skill info
    cmd_info "$skill_name"
}

# Update external skills (local operation)
cmd_update() {
    local target="${1:-all}"

    if [[ ! -d "$EXTERNAL_CACHE" ]]; then
        log_info "No external skills installed."
        return
    fi

    log_info "Updating external skill repositories..."

    for repo_dir in "$EXTERNAL_CACHE"/*/; do
        [[ -d "$repo_dir/.git" ]] || continue

        local repo_name=$(basename "$repo_dir")
        echo -n "  $repo_name... "
        if git -C "$repo_dir" pull --quiet 2>/dev/null; then
            echo -e "${GREEN}updated${NC}"
        else
            echo -e "${YELLOW}failed${NC}"
        fi
    done

    # Refresh baton cache if available
    if baton_available; then
        curl -s -X POST "$BATON_URL/skills/refresh" &>/dev/null
        log_info "Baton skills cache refreshed"
    fi

    log_ok "Update complete"
}

# Remove external skill (local operation)
cmd_remove() {
    local name="${1:-}"

    if [[ -z "$name" ]]; then
        log_error "Usage: skills remove <name>"
        exit 1
    fi

    local skill_link="$SKILLS_DIR/$name"

    if [[ ! -L "$skill_link" ]]; then
        if [[ -d "$skill_link" ]]; then
            log_error "'$name' is a local skill. Remove manually if needed."
        else
            log_error "Skill not found: $name"
        fi
        exit 1
    fi

    rm "$skill_link"
    log_ok "Removed: $name"
    log_info "Repository cache preserved in $EXTERNAL_CACHE"

    # Refresh baton cache if available
    if baton_available; then
        curl -s -X POST "$BATON_URL/skills/refresh" &>/dev/null
    fi
}

# Show skill info
cmd_info() {
    local name="${1:-}"

    if [[ -z "$name" ]]; then
        log_error "Usage: skills info <name>"
        exit 1
    fi

    # Try baton first
    if baton_available; then
        local result
        result=$(baton_skills_get "$name")

        local error
        error=$(echo "$result" | jq -r '.detail // ""')
        if [[ -z "$error" ]] || [[ "$error" == "null" ]]; then
            echo -e "${BOLD}Skill: $name${NC}"
            echo ""
            echo "$result" | jq -r '
                "Path: \(.path)",
                "",
                "Metadata:",
                (.metadata | to_entries[] | "  \(.key): \(.value)")
            ' 2>/dev/null || true
            return
        fi
    fi

    # Fallback to local
    local skill_dir="$SKILLS_DIR/$name"
    local skill_file="$skill_dir/SKILL.md"

    if [[ ! -f "$skill_file" ]]; then
        log_error "Skill not found: $name"
        exit 1
    fi

    echo -e "${BLUE}Skill: $name${NC}"
    echo ""

    # Check if external
    if [[ -L "$skill_dir" ]]; then
        local target=$(readlink -f "$skill_dir")
        echo -e "Type:   ${YELLOW}External${NC}"
        echo "Source: $target"
    else
        echo -e "Type:   ${GREEN}Local${NC}"
    fi

    # Parse frontmatter
    local description=""
    local in_frontmatter=false

    while IFS= read -r line; do
        if [[ "$line" == "---" ]]; then
            if [[ "$in_frontmatter" == "false" ]]; then
                in_frontmatter=true
            else
                break
            fi
            continue
        fi

        if [[ "$in_frontmatter" == "true" ]]; then
            if [[ "$line" == description:* ]]; then
                description="${line#description: }"
                description="${description//\"/}"
            fi
        fi
    done < "$skill_file"

    if [[ -n "$description" ]]; then
        echo ""
        echo "Description:"
        echo "  $description" | fold -s -w 70 | sed 's/^/  /'
    fi

    # Show structure
    echo ""
    echo "Contents:"
    [[ -d "$skill_dir/scripts" ]] && echo "  scripts/:    $(ls "$skill_dir/scripts" 2>/dev/null | wc -l) files"
    [[ -d "$skill_dir/references" ]] && echo "  references/: $(ls "$skill_dir/references" 2>/dev/null | wc -l) files"
    [[ -d "$skill_dir/assets" ]] && echo "  assets/:     $(ls "$skill_dir/assets" 2>/dev/null | wc -l) files"
}

# Validate SKILL.md format (local operation)
cmd_validate() {
    local name="${1:-}"
    local errors=0
    local warnings=0

    validate_skill() {
        local skill_dir="$1"
        local skill_name=$(basename "$skill_dir")
        local skill_file="$skill_dir/SKILL.md"

        [[ -f "$skill_file" ]] || return 0

        local has_frontmatter=false
        local has_name=false
        local has_description=false
        local name_value=""
        local desc_value=""

        local in_frontmatter=false
        while IFS= read -r line; do
            if [[ "$line" == "---" ]]; then
                if [[ "$in_frontmatter" == "false" ]]; then
                    in_frontmatter=true
                    has_frontmatter=true
                else
                    break
                fi
                continue
            fi

            if [[ "$in_frontmatter" == "true" ]]; then
                if [[ "$line" == name:* ]]; then
                    has_name=true
                    name_value="${line#name: }"
                fi
                if [[ "$line" == description:* ]]; then
                    has_description=true
                    desc_value="${line#description: }"
                fi
            fi
        done < "$skill_file"

        local skill_errors=0

        if [[ "$has_frontmatter" != "true" ]]; then
            echo -e "  ${RED}✗${NC} Missing YAML frontmatter"
            ((skill_errors++))
        fi

        if [[ "$has_name" != "true" ]]; then
            echo -e "  ${RED}✗${NC} Missing 'name' field"
            ((skill_errors++))
        elif [[ ! "$name_value" =~ ^[a-z0-9-]+$ ]]; then
            echo -e "  ${YELLOW}!${NC} Name should be lowercase-hyphenated: $name_value"
            ((warnings++))
        fi

        if [[ "$has_description" != "true" ]]; then
            echo -e "  ${RED}✗${NC} Missing 'description' field"
            ((skill_errors++))
        elif [[ ${#desc_value} -gt 1024 ]]; then
            echo -e "  ${YELLOW}!${NC} Description exceeds 1024 chars"
            ((warnings++))
        elif [[ -z "$desc_value" ]] || [[ "$desc_value" == "|" ]]; then
            echo -e "  ${YELLOW}!${NC} Empty description"
            ((warnings++))
        fi

        if [[ $skill_errors -eq 0 ]]; then
            echo -e "  ${GREEN}✓${NC} Valid"
        fi

        return $skill_errors
    }

    if [[ -n "$name" ]]; then
        echo "Validating: $name"
        validate_skill "$SKILLS_DIR/$name" || ((errors++))
    else
        echo "Validating all skills..."
        echo ""

        for skill_dir in "$SKILLS_DIR"/*/; do
            [[ -d "$skill_dir" ]] || continue
            local sname=$(basename "$skill_dir")
            [[ "$sname" == .* ]] && continue

            echo "$sname:"
            validate_skill "$skill_dir" || ((errors++))
        done
    fi

    echo ""
    if [[ $errors -gt 0 ]]; then
        log_warn "$errors skill(s) have errors, $warnings warning(s)"
        return 1
    else
        log_ok "All skills valid ($warnings warning(s))"
    fi
}

# ============================================
# MAIN
# ============================================

cmd="${1:-list}"
shift 2>/dev/null || true

case "$cmd" in
    list|ls|"")     cmd_list "$@" ;;
    search|s|find)  cmd_search "$@" ;;
    best|top)       cmd_best "$@" ;;
    install|i|add)  cmd_install "$@" ;;
    update|u|pull)  cmd_update "$@" ;;
    remove|rm|del)  cmd_remove "$@" ;;
    info|show)      cmd_info "$@" ;;
    validate|check) cmd_validate "$@" ;;
    help|-h|--help) usage ;;
    *)
        log_error "Unknown command: $cmd"
        echo ""
        usage
        exit 1
        ;;
esac
