#!/usr/bin/env bash
# skills - Manage LifeMaestro skills (local and external)
# Supports installing from GitHub and browsing SkillsMP.com

set -uo pipefail

MAESTRO_ROOT="${MAESTRO_ROOT:-$(cd "$(dirname "$0")/.." && pwd)}"
SKILLS_DIR="$MAESTRO_ROOT/.claude/skills"
EXTERNAL_CACHE="$MAESTRO_ROOT/.cache/external-skills"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
DIM='\033[2m'
NC='\033[0m'

log_info()  { echo -e "${BLUE}ℹ${NC} $*"; }
log_ok()    { echo -e "${GREEN}✓${NC} $*"; }
log_warn()  { echo -e "${YELLOW}!${NC} $*"; }
log_error() { echo -e "${RED}✗${NC} $*" >&2; }

usage() {
    cat <<EOF
skills - Manage LifeMaestro agent skills

Usage: skills [command] [args...]

Commands:
    list                    List all installed skills (default)
    search <query>          Search SkillsMP.com for skills
    install <source>        Install skill from GitHub
    update [name]           Update external skills
    remove <name>           Remove an external skill
    info <name>             Show skill details
    validate [name]         Validate SKILL.md format

Install Sources:
    GitHub:     skills install owner/repo/path/to/skill
    Anthropic:  skills install anthropic:skill-name

Examples:
    skills list
    skills search "pdf processing"
    skills install anthropics/skills/skills/document-skills
    skills install anthropic:pdf
    skills update

EOF
}

# Extract description from SKILL.md frontmatter
get_description() {
    local skill_file="$1"
    awk '
        /^description:/ {
            if ($0 ~ /description: [^|]/) {
                sub(/^description: */, "")
                gsub(/"/, "")
                print
                exit
            }
            getline
            while (/^  [^-]/ && !/license:/ && !/allowed/) {
                gsub(/^  /, "")
                print
                exit
            }
        }
    ' "$skill_file"
}

# Print a skill entry
print_skill() {
    local skill_dir="$1"
    local is_external="${2:-false}"
    local name
    name=$(basename "$skill_dir")

    if [[ -f "$skill_dir/SKILL.md" ]]; then
        local desc
        desc=$(get_description "$skill_dir/SKILL.md")
        if [[ "$is_external" == "true" ]]; then
            printf "  %-28s %s ${DIM}[ext]${NC}\n" "$name" "${desc:0:40}"
        else
            printf "  %-28s %s\n" "$name" "${desc:0:45}"
        fi
    else
        printf "  %-28s ${DIM}(no SKILL.md)${NC}\n" "$name"
    fi
}

# Print a group of skills by prefix
print_group() {
    local prefix="$1"
    local label="$2"
    local color="$3"
    local found=0

    for skill_dir in "$SKILLS_DIR"/${prefix}*/; do
        if [[ -d "$skill_dir" ]]; then
            if [[ $found -eq 0 ]]; then
                echo -e "${color}${label}:${NC}"
                found=1
            fi
            local is_ext="false"
            [[ -L "${skill_dir%/}" ]] && is_ext="true"
            print_skill "$skill_dir" "$is_ext"
        fi
    done
    [[ $found -eq 1 ]] && echo ""
}

# List all installed skills
cmd_list() {
    echo -e "${BLUE}Available Skills${NC}"
    echo ""

    # Local skills (no prefix)
    echo -e "${GREEN}Local Skills:${NC}"
    for skill_dir in "$SKILLS_DIR"/*/; do
        [[ -d "$skill_dir" ]] || continue
        name=$(basename "$skill_dir")
        # Skip prefixed and hidden
        [[ "$name" == pai-* || "$name" == anthropic-* || "$name" == .* ]] && continue
        local is_ext="false"
        [[ -L "${skill_dir%/}" ]] && is_ext="true"
        print_skill "$skill_dir" "$is_ext"
    done
    echo ""

    print_group "pai-" "PAI Skills" "$YELLOW"
    print_group "anthropic-" "Anthropic Skills" "$BLUE"

    echo "Tip: Skills trigger on natural language. Just describe what you want!"
    echo "     Run 'skills search <query>' to find more skills on SkillsMP.com"
}

# Search SkillsMP.com
cmd_search() {
    local query="${1:-}"

    if [[ -z "$query" ]]; then
        log_error "Usage: skills search <query>"
        exit 1
    fi

    log_info "Searching SkillsMP.com for: $query"
    echo ""

    # URL encode query
    local encoded_query=$(echo "$query" | sed 's/ /+/g')
    local url="https://skillsmp.com/?q=$encoded_query"

    echo "Opening: $url"
    echo ""

    if command -v xdg-open &>/dev/null; then
        xdg-open "$url" 2>/dev/null &
    elif command -v open &>/dev/null; then
        open "$url" 2>/dev/null &
    else
        echo "Visit: $url"
    fi

    echo "Find a skill you like, then install with:"
    echo "  skills install <github-owner>/<repo>/<path-to-skill>"
    echo ""
    echo "Example:"
    echo "  skills install anthropics/skills/skills/document-skills"
}

# Install skill from GitHub
cmd_install() {
    local source="${1:-}"

    if [[ -z "$source" ]]; then
        log_error "Usage: skills install <source>"
        echo ""
        echo "Sources:"
        echo "  GitHub:    owner/repo/path/to/skill"
        echo "  Anthropic: anthropic:skill-name"
        exit 1
    fi

    # Handle anthropic: shorthand
    if [[ "$source" == anthropic:* ]]; then
        local skill_name="${source#anthropic:}"
        source="anthropics/skills/skills/$skill_name"
    fi

    # Parse GitHub path: owner/repo/path
    local owner repo skill_path skill_name

    # Split by /
    IFS='/' read -r owner repo rest <<< "$source"

    if [[ -z "$owner" ]] || [[ -z "$repo" ]]; then
        log_error "Invalid source format. Use: owner/repo/path/to/skill"
        exit 1
    fi

    # Reconstruct skill path (everything after owner/repo)
    skill_path="${source#$owner/$repo/}"
    skill_name=$(basename "$skill_path")

    log_info "Installing skill: $skill_name"
    log_info "  From: github.com/$owner/$repo"
    log_info "  Path: $skill_path"

    # Create cache directory
    mkdir -p "$EXTERNAL_CACHE"

    # Clone or update the repo
    local repo_dir="$EXTERNAL_CACHE/$owner-$repo"

    if [[ -d "$repo_dir/.git" ]]; then
        log_info "Updating repository..."
        git -C "$repo_dir" pull --quiet 2>/dev/null || log_warn "Could not update repo"
    else
        log_info "Cloning repository..."
        if ! git clone --depth 1 --quiet "https://github.com/$owner/$repo.git" "$repo_dir" 2>/dev/null; then
            log_error "Failed to clone repository"
            exit 1
        fi
    fi

    # Verify skill exists
    local source_skill_dir="$repo_dir/$skill_path"

    if [[ ! -f "$source_skill_dir/SKILL.md" ]]; then
        log_error "No SKILL.md found at: $skill_path"
        log_error "Available paths:"
        find "$repo_dir" -name "SKILL.md" -type f 2>/dev/null | head -5 | sed "s|$repo_dir/||" | sed 's|/SKILL.md||' | sed 's/^/  /'
        exit 1
    fi

    # Create symlink
    local link_name="$SKILLS_DIR/$skill_name"

    if [[ -e "$link_name" ]]; then
        if [[ -L "$link_name" ]]; then
            log_warn "Skill already installed, updating link..."
            rm "$link_name"
        else
            log_error "Local skill with same name exists: $skill_name"
            exit 1
        fi
    fi

    ln -s "$source_skill_dir" "$link_name"

    log_ok "Installed: $skill_name"
    echo ""

    # Show skill info
    cmd_info "$skill_name"
}

# Update external skills
cmd_update() {
    local target="${1:-all}"

    if [[ ! -d "$EXTERNAL_CACHE" ]]; then
        log_info "No external skills installed."
        return
    fi

    log_info "Updating external skill repositories..."

    for repo_dir in "$EXTERNAL_CACHE"/*/; do
        [[ -d "$repo_dir/.git" ]] || continue

        local repo_name=$(basename "$repo_dir")
        echo -n "  $repo_name... "
        if git -C "$repo_dir" pull --quiet 2>/dev/null; then
            echo -e "${GREEN}updated${NC}"
        else
            echo -e "${YELLOW}failed${NC}"
        fi
    done

    log_ok "Update complete"
}

# Remove external skill
cmd_remove() {
    local name="${1:-}"

    if [[ -z "$name" ]]; then
        log_error "Usage: skills remove <name>"
        exit 1
    fi

    local skill_link="$SKILLS_DIR/$name"

    if [[ ! -L "$skill_link" ]]; then
        if [[ -d "$skill_link" ]]; then
            log_error "'$name' is a local skill. Remove manually if needed."
        else
            log_error "Skill not found: $name"
        fi
        exit 1
    fi

    rm "$skill_link"
    log_ok "Removed: $name"
    log_info "Repository cache preserved in $EXTERNAL_CACHE"
}

# Show skill info
cmd_info() {
    local name="${1:-}"

    if [[ -z "$name" ]]; then
        log_error "Usage: skills info <name>"
        exit 1
    fi

    local skill_dir="$SKILLS_DIR/$name"
    local skill_file="$skill_dir/SKILL.md"

    if [[ ! -f "$skill_file" ]]; then
        log_error "Skill not found: $name"
        exit 1
    fi

    echo -e "${BLUE}Skill: $name${NC}"
    echo ""

    # Check if external
    if [[ -L "$skill_dir" ]]; then
        local target=$(readlink -f "$skill_dir")
        echo -e "Type:   ${YELLOW}External${NC}"
        echo "Source: $target"
    else
        echo -e "Type:   ${GREEN}Local${NC}"
    fi

    # Parse frontmatter
    local description=""
    local in_frontmatter=false

    while IFS= read -r line; do
        if [[ "$line" == "---" ]]; then
            if [[ "$in_frontmatter" == "false" ]]; then
                in_frontmatter=true
            else
                break
            fi
            continue
        fi

        if [[ "$in_frontmatter" == "true" ]]; then
            if [[ "$line" == description:* ]]; then
                description="${line#description: }"
                description="${description//\"/}"
            fi
        fi
    done < "$skill_file"

    if [[ -n "$description" ]]; then
        echo ""
        echo "Description:"
        echo "  $description" | fold -s -w 70 | sed 's/^/  /'
    fi

    # Show structure
    echo ""
    echo "Contents:"
    [[ -d "$skill_dir/scripts" ]] && echo "  scripts/:    $(ls "$skill_dir/scripts" 2>/dev/null | wc -l) files"
    [[ -d "$skill_dir/references" ]] && echo "  references/: $(ls "$skill_dir/references" 2>/dev/null | wc -l) files"
    [[ -d "$skill_dir/assets" ]] && echo "  assets/:     $(ls "$skill_dir/assets" 2>/dev/null | wc -l) files"
}

# Validate SKILL.md format
cmd_validate() {
    local name="${1:-}"
    local errors=0
    local warnings=0

    validate_skill() {
        local skill_dir="$1"
        local skill_name=$(basename "$skill_dir")
        local skill_file="$skill_dir/SKILL.md"

        [[ -f "$skill_file" ]] || return 0

        local has_frontmatter=false
        local has_name=false
        local has_description=false
        local name_value=""
        local desc_value=""

        local in_frontmatter=false
        while IFS= read -r line; do
            if [[ "$line" == "---" ]]; then
                if [[ "$in_frontmatter" == "false" ]]; then
                    in_frontmatter=true
                    has_frontmatter=true
                else
                    break
                fi
                continue
            fi

            if [[ "$in_frontmatter" == "true" ]]; then
                if [[ "$line" == name:* ]]; then
                    has_name=true
                    name_value="${line#name: }"
                fi
                if [[ "$line" == description:* ]]; then
                    has_description=true
                    desc_value="${line#description: }"
                fi
            fi
        done < "$skill_file"

        local skill_errors=0

        if [[ "$has_frontmatter" != "true" ]]; then
            echo -e "  ${RED}✗${NC} Missing YAML frontmatter"
            ((skill_errors++))
        fi

        if [[ "$has_name" != "true" ]]; then
            echo -e "  ${RED}✗${NC} Missing 'name' field"
            ((skill_errors++))
        elif [[ ! "$name_value" =~ ^[a-z0-9-]+$ ]]; then
            echo -e "  ${YELLOW}!${NC} Name should be lowercase-hyphenated: $name_value"
            ((warnings++))
        fi

        if [[ "$has_description" != "true" ]]; then
            echo -e "  ${RED}✗${NC} Missing 'description' field"
            ((skill_errors++))
        elif [[ ${#desc_value} -gt 1024 ]]; then
            echo -e "  ${YELLOW}!${NC} Description exceeds 1024 chars"
            ((warnings++))
        elif [[ -z "$desc_value" ]] || [[ "$desc_value" == "|" ]]; then
            echo -e "  ${YELLOW}!${NC} Empty description"
            ((warnings++))
        fi

        if [[ $skill_errors -eq 0 ]]; then
            echo -e "  ${GREEN}✓${NC} Valid"
        fi

        return $skill_errors
    }

    if [[ -n "$name" ]]; then
        echo "Validating: $name"
        validate_skill "$SKILLS_DIR/$name" || ((errors++))
    else
        echo "Validating all skills..."
        echo ""

        for skill_dir in "$SKILLS_DIR"/*/; do
            [[ -d "$skill_dir" ]] || continue
            local sname=$(basename "$skill_dir")
            [[ "$sname" == .* ]] && continue

            echo "$sname:"
            validate_skill "$skill_dir" || ((errors++))
        done
    fi

    echo ""
    if [[ $errors -gt 0 ]]; then
        log_warn "$errors skill(s) have errors, $warnings warning(s)"
        return 1
    else
        log_ok "All skills valid ($warnings warning(s))"
    fi
}

# Main
cmd="${1:-list}"
shift 2>/dev/null || true

case "$cmd" in
    list|ls|"")     cmd_list "$@" ;;
    search|s|find)  cmd_search "$@" ;;
    install|i|add)  cmd_install "$@" ;;
    update|u|pull)  cmd_update "$@" ;;
    remove|rm|del)  cmd_remove "$@" ;;
    info|show)      cmd_info "$@" ;;
    validate|check) cmd_validate "$@" ;;
    help|-h|--help) usage ;;
    *)
        log_error "Unknown command: $cmd"
        echo ""
        usage
        exit 1
        ;;
esac
