#!/usr/bin/env bash
# ai - Multi-client AI session launcher with transcript logging
# Usage: ai [client] [args...]
#
# Supported clients: claude, gemini, codex, aider
#
# This wrapper:
# 1. Detects/creates session context
# 2. Logs the full conversation transcript
# 3. Tracks client usage in .session.json

set -euo pipefail

MAESTRO_ROOT="${MAESTRO_ROOT:-${XDG_CONFIG_HOME:-$HOME/.config}/lifemaestro}"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
DIM='\033[2m'
NC='\033[0m'

log_info()  { echo -e "${BLUE}▶${NC} $*"; }
log_ok()    { echo -e "${GREEN}✓${NC} $*"; }
log_warn()  { echo -e "${YELLOW}!${NC} $*" >&2; }
log_error() { echo -e "${RED}✗${NC} $*" >&2; }

# Supported clients and their commands
declare -A CLIENT_COMMANDS=(
    [claude]="claude"
    [gemini]="gemini"
    [codex]="codex"
    [aider]="aider"
)

declare -A CLIENT_CONTEXT_FILES=(
    [claude]="CLAUDE.md"
    [gemini]="GEMINI.md"
    [codex]="AGENTS.md"
    [aider]="CONVENTIONS.md"
)

declare -A CLIENT_CONTEXT_FLAGS=(
    [claude]=""  # Auto-reads CLAUDE.md
    [gemini]=""  # Auto-reads GEMINI.md
    [codex]=""   # Auto-reads AGENTS.md
    [aider]="--read CONVENTIONS.md"  # Needs explicit flag
)

# Map clients to providers
declare -A CLIENT_PROVIDERS=(
    [claude]="anthropic"
    [gemini]="google"
    [codex]="openai"
    [aider]=""  # Aider uses its own config
)

usage() {
    cat <<EOF
ai - Multi-client AI session launcher

Usage: ai <client> [--via <method>] [client-args...]

Clients:
    claude      Claude Code (Anthropic)
    gemini      Gemini CLI (Google)
    codex       Codex CLI (OpenAI)
    aider       Aider (multi-model)

Options:
    --via <method>  Access method: oauth, api, bedrock, vertex, azure
                    (See 'ai-access status' for available methods)

Features:
    - Automatic transcript logging to transcripts/
    - Client usage tracking in .session.json
    - Shared context via CONTEXT.md symlinks
    - Clean auth switching between OAuth/API/Cloud

Examples:
    ai claude                    # Start Claude with default access (oauth)
    ai claude --via bedrock      # Start Claude with AWS Bedrock
    ai claude --via api          # Start Claude with API key
    ai gemini --via vertex       # Start Gemini with GCP Vertex AI
    ai aider --model claude-3   # Start Aider with specific model

Access Methods:
    anthropic:  oauth, api, bedrock
    google:     oauth, api, vertex
    openai:     api, azure

Environment:
    MAESTRO_ROOT    Config directory (default: ~/.config/lifemaestro)
    AI_NO_LOG       Set to 1 to disable transcript logging

See also:
    ai-access status            # Show current access configuration
    ai-access <provider> <method>  # Set default access method
EOF
}

# Check if a command exists
command_exists() {
    command -v "$1" &>/dev/null
}

# Track client usage in .session.json
track_client() {
    local client="$1"

    if [[ ! -f ".session.json" ]]; then
        return 0
    fi

    if ! command_exists jq; then
        return 0
    fi

    local now
    now=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    local tmp_file
    tmp_file=$(mktemp)

    # Update or add client tracking
    jq --arg client "$client" --arg now "$now" '
        # Ensure clients_used exists
        .clients_used //= []
        # Update or add client
        | if (.clients_used | map(.client) | index($client)) then
            .clients_used |= map(
                if .client == $client then
                    .invocations += 1 | .last_used = $now
                else
                    .
                end
            )
        else
            .clients_used += [{
                "client": $client,
                "invocations": 1,
                "first_used": $now,
                "last_used": $now
            }]
        end
        # Set primary_client to most-used
        | .primary_client = (.clients_used | max_by(.invocations) | .client)
    ' .session.json > "$tmp_file" 2>/dev/null || return 0

    mv "$tmp_file" .session.json
}

# Get transcript filename
get_transcript_file() {
    local client="$1"
    local timestamp
    timestamp=$(date +"%Y-%m-%dT%H-%M-%S")

    # Ensure transcripts directory exists
    mkdir -p transcripts

    echo "transcripts/${timestamp}-${client}.log"
}

# Setup access method environment
setup_access_env() {
    local provider="$1"
    local method="$2"

    if [[ -z "$provider" ]]; then
        return 0
    fi

    local ai_access_cmd="${MAESTRO_ROOT}/../bin/ai-access"
    if [[ ! -x "$ai_access_cmd" ]]; then
        ai_access_cmd="ai-access"
    fi

    if ! command_exists "$ai_access_cmd" && [[ ! -x "$ai_access_cmd" ]]; then
        log_warn "ai-access not found, skipping environment setup"
        return 0
    fi

    # Get environment setup commands
    local env_setup
    if [[ -n "$method" ]]; then
        env_setup=$("$ai_access_cmd" env "$provider" "$method" 2>/dev/null)
    else
        env_setup=$("$ai_access_cmd" env "$provider" 2>/dev/null)
    fi

    # Apply environment
    eval "$env_setup"

    log_info "Access: $provider via ${method:-default}"
}

# Main
main() {
    local client="${1:-}"
    shift || true

    # Handle help
    if [[ "$client" == "-h" ]] || [[ "$client" == "--help" ]] || [[ -z "$client" ]]; then
        usage
        exit 0
    fi

    # Validate client
    if [[ -z "${CLIENT_COMMANDS[$client]:-}" ]]; then
        log_error "Unknown client: $client"
        echo "Supported clients: ${!CLIENT_COMMANDS[*]}"
        exit 1
    fi

    # Parse --via flag
    local via_method=""
    local client_args=()
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --via)
                via_method="${2:-}"
                shift 2 || { log_error "--via requires a method"; exit 1; }
                ;;
            *)
                client_args+=("$1")
                shift
                ;;
        esac
    done

    local cmd="${CLIENT_COMMANDS[$client]}"
    local context_file="${CLIENT_CONTEXT_FILES[$client]}"
    local context_flags="${CLIENT_CONTEXT_FLAGS[$client]}"
    local provider="${CLIENT_PROVIDERS[$client]:-}"

    # Setup access environment (clears conflicting auth, sets correct method)
    setup_access_env "$provider" "$via_method"

    # Check if client command exists
    if ! command_exists "$cmd"; then
        log_error "Client not installed: $cmd"
        echo "Install $client and ensure '$cmd' is in your PATH"
        exit 1
    fi

    # Check for context file (session detection)
    if [[ -f "$context_file" ]] || [[ -L "$context_file" ]]; then
        log_info "Session detected: $context_file"
    else
        log_warn "No session context found ($context_file)"
        log_warn "Run 'session new' to create a session, or continue without context"
    fi

    # Track client usage
    track_client "$client"

    # Determine if logging is enabled
    local do_log=true
    if [[ "${AI_NO_LOG:-}" == "1" ]]; then
        do_log=false
    fi

    # Build command with any extra flags
    local full_cmd="$cmd"
    if [[ -n "$context_flags" ]]; then
        full_cmd="$cmd $context_flags"
    fi

    # Add user's additional args (after parsing --via)
    if [[ ${#client_args[@]} -gt 0 ]]; then
        full_cmd="$full_cmd ${client_args[*]}"
    fi

    if [[ "$do_log" == "true" ]]; then
        local transcript_file
        transcript_file=$(get_transcript_file "$client")

        log_info "Starting $client with transcript logging"
        log_info "Transcript: $transcript_file"
        echo ""

        # Use script command to capture full terminal session
        # -q: quiet, -f: flush output, -c: command to run
        if [[ "$(uname)" == "Darwin" ]]; then
            # macOS script syntax
            script -q "$transcript_file" $full_cmd
        else
            # Linux script syntax
            script -q -f -c "$full_cmd" "$transcript_file"
        fi

        log_ok "Session ended. Transcript saved: $transcript_file"

        # Strip ANSI codes from transcript for cleaner git diffs
        if command_exists sed; then
            sed -i 's/\x1b\[[0-9;]*m//g' "$transcript_file" 2>/dev/null || true
            sed -i 's/\x1b\[[0-9;]*[a-zA-Z]//g' "$transcript_file" 2>/dev/null || true
        fi
    else
        log_info "Starting $client (logging disabled)"
        echo ""
        exec $full_cmd
    fi
}

main "$@"
