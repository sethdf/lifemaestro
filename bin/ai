#!/usr/bin/env bash
# ai - Multi-client AI session launcher with transcript logging
# Usage: ai [client] [args...]
#
# Supported clients: claude, gemini, codex, aider
#
# This wrapper:
# 1. Detects/creates session context
# 2. Logs the full conversation transcript
# 3. Tracks client usage in .session.json

set -euo pipefail

MAESTRO_ROOT="${MAESTRO_ROOT:-${XDG_CONFIG_HOME:-$HOME/.config}/lifemaestro}"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
DIM='\033[2m'
NC='\033[0m'

log_info()  { echo -e "${BLUE}▶${NC} $*"; }
log_ok()    { echo -e "${GREEN}✓${NC} $*"; }
log_warn()  { echo -e "${YELLOW}!${NC} $*" >&2; }
log_error() { echo -e "${RED}✗${NC} $*" >&2; }

# Supported clients and their commands
declare -A CLIENT_COMMANDS=(
    [claude]="claude"
    [gemini]="gemini"
    [codex]="codex"
    [aider]="aider"
)

declare -A CLIENT_CONTEXT_FILES=(
    [claude]="CLAUDE.md"
    [gemini]="GEMINI.md"
    [codex]="AGENTS.md"
    [aider]="CONVENTIONS.md"
)

declare -A CLIENT_CONTEXT_FLAGS=(
    [claude]=""  # Auto-reads CLAUDE.md
    [gemini]=""  # Auto-reads GEMINI.md
    [codex]=""   # Auto-reads AGENTS.md
    [aider]="--read CONVENTIONS.md"  # Needs explicit flag
)

usage() {
    cat <<EOF
ai - Multi-client AI session launcher

Usage: ai <client> [client-args...]

Clients:
    claude      Claude Code (Anthropic)
    gemini      Gemini CLI (Google)
    codex       Codex CLI (OpenAI)
    aider       Aider (multi-model)

Features:
    - Automatic transcript logging to transcripts/
    - Client usage tracking in .session.json
    - Shared context via CONTEXT.md symlinks

Examples:
    ai claude                    # Start Claude Code with logging
    ai gemini                    # Start Gemini CLI with logging
    ai aider --model claude-3   # Start Aider with specific model
    ai codex --help              # Pass args to codex

Environment:
    MAESTRO_ROOT    Config directory (default: ~/.config/lifemaestro)
    AI_NO_LOG       Set to 1 to disable transcript logging
EOF
}

# Check if a command exists
command_exists() {
    command -v "$1" &>/dev/null
}

# Track client usage in .session.json
track_client() {
    local client="$1"

    if [[ ! -f ".session.json" ]]; then
        return 0
    fi

    if ! command_exists jq; then
        return 0
    fi

    local now
    now=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    local tmp_file
    tmp_file=$(mktemp)

    # Update or add client tracking
    jq --arg client "$client" --arg now "$now" '
        # Ensure clients_used exists
        .clients_used //= []
        # Update or add client
        | if (.clients_used | map(.client) | index($client)) then
            .clients_used |= map(
                if .client == $client then
                    .invocations += 1 | .last_used = $now
                else
                    .
                end
            )
        else
            .clients_used += [{
                "client": $client,
                "invocations": 1,
                "first_used": $now,
                "last_used": $now
            }]
        end
        # Set primary_client to most-used
        | .primary_client = (.clients_used | max_by(.invocations) | .client)
    ' .session.json > "$tmp_file" 2>/dev/null || return 0

    mv "$tmp_file" .session.json
}

# Get transcript filename
get_transcript_file() {
    local client="$1"
    local timestamp
    timestamp=$(date +"%Y-%m-%dT%H-%M-%S")

    # Ensure transcripts directory exists
    mkdir -p transcripts

    echo "transcripts/${timestamp}-${client}.log"
}

# Main
main() {
    local client="${1:-}"
    shift || true

    # Handle help
    if [[ "$client" == "-h" ]] || [[ "$client" == "--help" ]] || [[ -z "$client" ]]; then
        usage
        exit 0
    fi

    # Validate client
    if [[ -z "${CLIENT_COMMANDS[$client]:-}" ]]; then
        log_error "Unknown client: $client"
        echo "Supported clients: ${!CLIENT_COMMANDS[*]}"
        exit 1
    fi

    local cmd="${CLIENT_COMMANDS[$client]}"
    local context_file="${CLIENT_CONTEXT_FILES[$client]}"
    local context_flags="${CLIENT_CONTEXT_FLAGS[$client]}"

    # Check if client command exists
    if ! command_exists "$cmd"; then
        log_error "Client not installed: $cmd"
        echo "Install $client and ensure '$cmd' is in your PATH"
        exit 1
    fi

    # Check for context file (session detection)
    if [[ -f "$context_file" ]] || [[ -L "$context_file" ]]; then
        log_info "Session detected: $context_file"
    else
        log_warn "No session context found ($context_file)"
        log_warn "Run 'session new' to create a session, or continue without context"
    fi

    # Track client usage
    track_client "$client"

    # Determine if logging is enabled
    local do_log=true
    if [[ "${AI_NO_LOG:-}" == "1" ]]; then
        do_log=false
    fi

    # Build command with any extra flags
    local full_cmd="$cmd"
    if [[ -n "$context_flags" ]]; then
        full_cmd="$cmd $context_flags"
    fi

    # Add user's additional args
    if [[ $# -gt 0 ]]; then
        full_cmd="$full_cmd $*"
    fi

    if [[ "$do_log" == "true" ]]; then
        local transcript_file
        transcript_file=$(get_transcript_file "$client")

        log_info "Starting $client with transcript logging"
        log_info "Transcript: $transcript_file"
        echo ""

        # Use script command to capture full terminal session
        # -q: quiet, -f: flush output, -c: command to run
        if [[ "$(uname)" == "Darwin" ]]; then
            # macOS script syntax
            script -q "$transcript_file" $full_cmd
        else
            # Linux script syntax
            script -q -f -c "$full_cmd" "$transcript_file"
        fi

        log_ok "Session ended. Transcript saved: $transcript_file"

        # Strip ANSI codes from transcript for cleaner git diffs
        if command_exists sed; then
            sed -i 's/\x1b\[[0-9;]*m//g' "$transcript_file" 2>/dev/null || true
            sed -i 's/\x1b\[[0-9;]*[a-zA-Z]//g' "$transcript_file" 2>/dev/null || true
        fi
    else
        log_info "Starting $client (logging disabled)"
        echo ""
        exec $full_cmd
    fi
}

main "$@"
